---
title: "![](assets/img/logo-uah-open.png){width=280px style='display:block; margin-bottom:40px; margin-left:0;'} An√°lisis EPI 2025"
subtitle: "Reporte de Resultados de Antropolog√≠a"
author: ""
logo: assets/img/logo-uah-open.png

params:
  archivo:
    value: "data/raw/BD REPORTE EPI ANTROPOLOG√çA (1).xlsx"
    label: "Archivo Excel (Resultados Individuales)"

format:
  revealjs:
    width: 1280
    height: 720
    theme:
      - default
      - styles/report.scss
    slide-number: true
    auto-stretch: false
    df-print: paged
    code-fold: true
    code-tools: true

execute:
  freeze: auto
  echo: true
  warning: false
  message: false
---

```{r setup, include=FALSE}
# Paquetes (sin pacman para m√°xima estabilidad)
pkgs <- c("tidyverse","readxl","janitor","readr","forcats","scales","glue","stringr","ggplot2","rlang","DT","kableExtra")
to_install <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
if (length(to_install)) install.packages(to_install)
invisible(lapply(pkgs, library, character.only = TRUE))

# Paleta / tipograf√≠a
brand_main   <- "#0a6d7c"
brand_dark   <- "#0a4e58"
brand_muted  <- "#4b5661"
brand_text   <- "#11222b"

# Colores institucionales (obligatorio)
col_autonomia <- brand_main                 # VERDE = color del tema
col_apoyo     <- scales::alpha("#c62828", 0.75)  # ROJO m√°s opaco
col_nr        <- "#9e9e9e"                   # GRIS neutro
col_desarrollo <- "#f9a825" # amarillo (solo para heatmap o desglose)


# Definiciones institucionales (obligatorias y consistentes)
CAT_AUT <- "Avanzan con autonom√≠a"
CAT_APO <- "Requieren apoyo formativo"

# Tipograf√≠a aumentada para proyecci√≥n
theme_set(theme_minimal(base_size = 22))
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
options(scipen = 999, dplyr.summarise.inform = FALSE)

fmt_pct <- function(x) scales::percent(x, accuracy = 0.1)

nivel_labels <- c(
  "0" = "No Obs.\n(0)",
  "1" = "Insatis.\n(1)",
  "2" = "En desarr.\n(2)",
  "3" = "Satisf.\n(3)",
  "4" = "√ìptimo\n(4)",
  "NR" = "No Resp.\n(NR)"
)
```

```{r labels_items, include=FALSE}
# DICCIONARIO DE T√çTULOS (ajusta seg√∫n tus columnas reales del Excel)
manual_titles <- c(
  "ENFOQUES TE√ìRICO-CONCEPTUALES DE LA ANTROPOLOG√çA Y SU RELACI√ìN CON UNA EXPERIENCIA DE TRABAJO ETNOGR√ÅFICO ESPEC√çFICO." =
    "Enfoques Te√≥rico-Conceptuales y Trabajo Etnogr√°fico",

  "ELEMENTOS FUNDAMENTALES DE LA HISTORIA Y EL PENSAMIENTO LATINOAMERICANO PARA COMPRENDER UN PROBLEMA DE INVESTIGACI√ìN ESPEC√çFICO." =
    "Historia y Pensamiento Latinoamericano",

  "FUNDAMENTOS Y ESTRATEGIAS DE LAS METODOLOG√çAS CUALITATIVAS Y LA ETNOGRAF√çA PARA FORMULAR PROYECTOS DE INVESTIGACI√ìN ANTROPOL√ìGICA." =
    "Metodolog√≠as Cualitativas y Etnograf√≠a",

  "HERRAMIENTAS INTRODUCTORIAS DEL TRABAJO ETNOGR√ÅFICO, INCORPORANDO EL DISE√ëO, IMPLEMENTACI√ìN Y REPORTE ESCRITO (AN√ÅLISIS)" =
    "Herramientas del Trabajo Etnogr√°fico (Dise√±o y Reporte)",

  "ESPECIFICIDADES DISCIPLINARES DE LA ANTROPOLOG√çA Y SU RELACI√ìN CON OTRAS DISCIPLINAS DE LAS CIENCIAS HUMANAS." =
    "Especificidades Disciplinares e Interdisciplina",

  "ASPECTOS FORMALES ASOCIADOS AL ENSAYO" =
    "Aspectos Formales (Ensayo)"
)
```

```{r parser, include=FALSE}
parse_deep_excel <- function(path){

  # Normalizar y validar ruta
  path <- normalizePath(path, mustWork = FALSE)
  if (!file.exists(path)) {
    stop(glue::glue(
      "No se encontr√≥ el archivo Excel en la ruta:\n{path}\n",
      "Verifica params$archivo o renderiza desde el directorio correcto."
    ))
  }

  # Verificar hoja requerida
  sheets <- readxl::excel_sheets(path)
  target_sheet <- "Resultados Individuales"
  if (!(target_sheet %in% sheets)) {
    stop(glue::glue(
      "No existe la hoja '{target_sheet}'.\n",
      "Hojas disponibles: {paste(sheets, collapse = ', ')}"
    ))
  }

  # Leer bloque inicial para detectar fila encabezados
  raw_block <- suppressMessages(read_excel(
    path,
    sheet = target_sheet,
    col_names = FALSE,
    n_max = 50,
    .name_repair = "minimal",
    col_types = "text"
  ))

  header_row_idx <- which(apply(raw_block, 1, function(x)
    any(str_detect(toupper(x), "RUT"), na.rm = TRUE)
  ))[1]

  if (is.na(header_row_idx)) {
    stop("No se pudo detectar la fila de encabezados (no se encontr√≥ 'RUT').")
  }

  # Leer encabezados reales
  headers_df <- suppressMessages(read_excel(
    path,
    sheet = target_sheet,
    skip = header_row_idx - 1,
    n_max = 1,
    .name_repair = "minimal",
    col_types = "text"
  ))

  raw_headers   <- colnames(headers_df)
  clean_headers <- str_squish(toupper(raw_headers))

  # Matching robusto de columnas (no exacto)
  target_cols <- names(manual_titles)

  valid_indices <- which(
    purrr::map_lgl(
      clean_headers,
      ~ any(str_detect(.x, fixed(target_cols, ignore_case = TRUE)))
    )
  )

  if (length(valid_indices) == 0) {
    stop(
      "No se detectaron columnas evaluativas.\n",
      "Revisa que los t√≠tulos del Excel correspondan a manual_titles."
    )
  }

  # Leer datos completos
  raw_data <- suppressMessages(read_excel(
    path,
    sheet = target_sheet,
    col_names = FALSE,
    skip = header_row_idx,
    .name_repair = "minimal",
    col_types = "text"
  ))

  dat_subset <- raw_data[, valid_indices]
  final_col_ids <- paste0("item_", seq_along(valid_indices))
  colnames(dat_subset) <- final_col_ids

  dat <- dat_subset %>%
    mutate(across(everything(), ~ na_if(str_trim(.x), ""))) %>%
    filter(!if_all(everything(), is.na)) %>%
    mutate(across(
      everything(),
      ~ ifelse(toupper(.x) %in% c("NR","N R","N-R"), "NR", .x)
    ))

  # Construir mapa de √≠tems
  found_headers <- purrr::map_chr(clean_headers[valid_indices], function(h){
    target_cols[
      which(str_detect(h, fixed(target_cols, ignore_case = TRUE)))[1]
    ]
  })

  final_titles_vec <- manual_titles[found_headers]

  mapa <- tibble(
    col_id      = final_col_ids,
    code        = found_headers,
    final_title = final_titles_vec
  )

  list(data = dat, map = mapa)
}

# Ejecuci√≥n
archivo <- normalizePath(params$archivo, mustWork = FALSE)
res <- parse_deep_excel(archivo)
dat <- res$data
final_items <- res$map
```

```{r labels_rubrica, include=FALSE}
# 1) R√∫brica Institucional (REFERENCIAL)
tabla_rubrica_inst <- tibble::tibble(
  Nivel = c("4 (√ìptimo)", "3 (Satisfactorio)", "2 (Base)", "1 (Por Mejorar)", "0 (No Obs)"),
  `% Referencia` = c("100%-85%", "84%-65%", "64%-50%", "49%-0%", "0 pts"),
  Descripci√≥n = c(
    "Avanza con autonom√≠a al ciclo de profundizaci√≥n. Cuenta con desempe√±os relevantes y demuestra un buen nivel de conocimientos te√≥rico-disciplinares.",
    "Avanza con autonom√≠a. Demuestra un conocimiento apropiado te√≥rico-disciplinar y manejo metodol√≥gico.",
    "Avanza con apoyos adicionales. Demuestra conocimiento b√°sico de contenidos esenciales, pero carece de profundidad.",
    "Avanza con apoyos adicionales. No alcanza un m√≠nimo de conocimiento de contenidos esperado.",
    "No presenta respuestas, lo que no permite evidenciar el logro de aprendizajes."
  )
)

# 2) R√∫brica Espec√≠fica (OPERACIONALIZA)
tabla_rubrica_eval <- tibble::tibble(
  Nivel = c("4", "3", "2", "1", "0", "NR"),
  Categor√≠a = c("√ìptimo", "Satisfactorio", "Aprendizajes en desarrollo", "Insatisfactorio", "No Observado", "No Responde"),
  Descripci√≥n = c(
    "Integra enfoques te√≥ricos y contextualizaci√≥n adecuada; comprensi√≥n anal√≠tica completa.",
    "Logro parcial con reconocimiento adecuado, pero con integraci√≥n/contextualizaci√≥n a√∫n parcial.",
    "Evidencia aprendizajes en desarrollo; requiere andamiaje para consolidar relaciones y comprensi√≥n.",
    "No identifica elementos fundamentales; impide relaciones o comprensiones m√≠nimas.",
    "No se observa el desempe√±o por ausencia de evidencia.",
    "Respuesta no registrada."
  )
)
```

## Marco institucional y prop√≥sito del EPI

:::{.div style="font-size: 25px; text-align: left; margin-top: 3.0em; line-height: 1.35;"}

- En el Modelo Pedag√≥gico institucional, los perfiles de ingreso, intermedio y egreso constituyen hitos evaluativos que estructuran las trayectorias formativas.

- La Evaluaci√≥n de Perfil Intermedio (EPI) es un hito formativo institucional que monitorea el desarrollo de competencias al t√©rmino del ciclo b√°sico.

- Su prop√≥sito es evaluar el grado de desarrollo de las competencias del perfil intermedio, distinguiendo entre:

  - **Estudiantes que avanzan con autonom√≠a**, y
  - **Estudiantes que requieren apoyo formativo**.

- El perfil intermedio define las competencias esperadas al finalizar el ciclo b√°sico y orienta la evaluaci√≥n.

- La EPI es una evaluaci√≥n integradora, compleja y formativa, cuyos resultados informan decisiones pedag√≥gicas sobre la continuidad con autonom√≠a o la continuidad con apoyos formativos.
:::


## R√∫brica general institucional

:::{.div style="font-size: 24px; text-align: left; margin-top: 4em;"}

```{r show_rubrica_inst, echo=FALSE, message=FALSE, warning=FALSE}

tabla_rubrica_inst2 <- tabla_rubrica_inst %>%
  # 1) Categor√≠a anal√≠tica (2 grandes grupos)
  dplyr::mutate(
    `Categor√≠a anal√≠tica` = dplyr::case_when(
      stringr::str_detect(Nivel, "^4") ~ CAT_AUT,
      stringr::str_detect(Nivel, "^3") ~ CAT_AUT,
      TRUE ~ CAT_APO
    ),
    # 2) Orden correcto por nivel (num√©rico)
    nivel_ord = dplyr::case_when(
      stringr::str_detect(Nivel, "^4") ~ 4,
      stringr::str_detect(Nivel, "^3") ~ 3,
      stringr::str_detect(Nivel, "^2") ~ 2,
      stringr::str_detect(Nivel, "^1") ~ 1,
      stringr::str_detect(Nivel, "^0") ~ 0,
      TRUE ~ -1
    )
  ) %>%
  # 3) Orden pedag√≥gico correcto dentro de cada categor√≠a
  dplyr::arrange(
    factor(`Categor√≠a anal√≠tica`, levels = c(CAT_AUT, CAT_APO)),
    dplyr::desc(nivel_ord)
  ) %>%
  # 4) Mostrar la categor√≠a solo una vez por bloque
  dplyr::mutate(
    `Categor√≠a anal√≠tica` = dplyr::if_else(
      duplicated(`Categor√≠a anal√≠tica`), "", `Categor√≠a anal√≠tica`
    )
  ) %>%
  # 5) Dejar SOLO las columnas finales (elimina nivel_ord)
  dplyr::select(`Categor√≠a anal√≠tica`, Nivel, `% Referencia`, Descripci√≥n)

tabla_rubrica_inst2 %>%
  kableExtra::kbl(
    format = "html",
    escape = FALSE,
    align = c("l", "l", "l", "l")
  ) %>%
  kableExtra::kable_styling(
    bootstrap_options = c("hover", "condensed"),
    full_width = TRUE,
    font_size = 20,
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, color = "white", background = brand_main) %>%
  # ‚úÖ Anchos: dale espacio real a "Descripci√≥n"
  kableExtra::column_spec(
    1, width = "22%", bold = TRUE,
    extra_css = "vertical-align: top; padding: 10px;"
  ) %>%
  kableExtra::column_spec(
    2, width = "16%", bold = TRUE, color = brand_main,
    extra_css = "vertical-align: top; padding: 10px;"
  ) %>%
  kableExtra::column_spec(
    3, width = "14%", bold = TRUE,
    extra_css = "vertical-align: top; padding: 10px;"
  ) %>%
  kableExtra::column_spec(
    4, width = "48%",
    extra_css = "vertical-align: top; text-align: left; line-height: 1.25; padding: 10px; color: #4b5661;"
  )
```

:::

## R√∫brica espec√≠fica EPI del programa acad√©mico

:::{.div style="font-size: 24px; text-align: left; margin-top: 4em;"}
```{r show_rubrica_especifica, echo=FALSE, message=FALSE, warning=FALSE}

# Asegura que exista el objeto
if (!exists("tabla_rubrica_eval") || is.null(tabla_rubrica_eval) || nrow(tabla_rubrica_eval) == 0) {
  cat("**No se encontr√≥ `tabla_rubrica_eval` o est√° vac√≠a.**\n")
} else {

  tabla_rubrica_eval2 <- tabla_rubrica_eval %>%
    dplyr::mutate(
      Nivel = as.character(Nivel),

      # Orden num√©rico (NR al final)
      nivel_ord = dplyr::case_when(
        Nivel %in% c("4","3","2","1","0") ~ as.numeric(Nivel),
        toupper(Nivel) == "NR" ~ -1,
        TRUE ~ -2
      ),

      # Categor√≠a anal√≠tica (dos bloques)
      `Categor√≠a anal√≠tica` = dplyr::case_when(
        Nivel %in% c("4","3") ~ CAT_AUT,
        TRUE ~ CAT_APO
      )
    ) %>%
    # Orden: primero autonom√≠a (4,3), luego apoyo (2,1,0,NR)
    dplyr::arrange(
      factor(`Categor√≠a anal√≠tica`, levels = c(CAT_AUT, CAT_APO)),
      dplyr::desc(nivel_ord)
    ) %>%
    # Mostrar el texto del bloque solo en la primera fila
    dplyr::mutate(
      `Categor√≠a anal√≠tica` = dplyr::if_else(
        duplicated(`Categor√≠a anal√≠tica`), "", `Categor√≠a anal√≠tica`
      )
    ) %>%
    # Orden final de columnas (sin dejar columnas auxiliares)
    dplyr::select(`Categor√≠a anal√≠tica`, Nivel, Categor√≠a, Descripci√≥n)

  tabla_rubrica_eval2 %>%
    kableExtra::kbl(format = "html", escape = FALSE, align = "llll") %>%
    kableExtra::kable_styling(
      bootstrap_options = c("hover", "condensed"),
      full_width = TRUE,
      font_size = 20,
      position = "center"
    ) %>%
    kableExtra::row_spec(0, bold = TRUE, color = "white", background = brand_main) %>%
    kableExtra::column_spec(1, width = "22%", bold = TRUE,
                            extra_css = "vertical-align: top; padding: 10px;") %>%
    kableExtra::column_spec(2, width = "10%", bold = TRUE, color = brand_main,
                            extra_css = "vertical-align: top; padding: 10px;") %>%
    kableExtra::column_spec(3, width = "22%", bold = TRUE,
                            extra_css = "vertical-align: top; padding: 10px;") %>%
    kableExtra::column_spec(4, width = "46%",
                            extra_css = "vertical-align: top; text-align: left; line-height: 1.25; padding: 10px; color: #4b5661;")
}
```

:::

## Criterio de lectura (orientado a decisiones)

:::{.div style="font-size: 28px; text-align: left; margin-top: 2.6em; line-height: 1.35;"}
- **Interpretaci√≥n principal:** se realizan desde la **el marco de categorias anal√≠ticas de nivel institucional (referencial)**.

- **Operacionalizaci√≥n:** se implementa mediante la **r√∫brica espec√≠fica aplicada** en esta evaluaci√≥n.
- Toda la lectura se estructura en torno a dos categor√≠as anal√≠ticas institucionales que uferon explicadas en las diapositivas anteriores:
  - **Estudiantes que avanzan con autonom√≠a**
  - **Estudiantes que requieren apoyo formativo**
  

:::

```{r plots_items, results='asis', echo=FALSE}
#| fig.width: 11
#| fig.height: 7.5

# Reglas de color (obligatorias):
# - Niveles 3‚Äì4 => VERDE (autonom√≠a)
# - Niveles 0‚Äì2 => ROJO (requieren apoyo)
# - NR => gris

if (nrow(final_items) == 0) {
  cat("### No se detectaron √≠tems.\n")
  cat("Verifique los nombres de columna en el Excel.")
} else {

  for (i in 1:nrow(final_items)) {

    row_info <- final_items[i, ]
    col_id   <- row_info$col_id
    titulo   <- row_info$final_title

    x <- dat[[col_id]]

    df <- tibble(raw = x) |>
      mutate(
        val = toupper(stringr::str_trim(as.character(raw))),
        clean_val = dplyr::case_when(
          stringr::str_detect(val, "\\bNR\\b") ~ "NR",
          TRUE ~ val
        ),
        num = suppressWarnings(readr::parse_number(clean_val)),
        level = dplyr::if_else(is.na(num), "NR", as.character(num)),
        level = factor(level, levels = c("0","1","2","3","4","NR"))
      ) |>
      count(level, name = "n") |>
      tidyr::complete(
        level = factor(c("0","1","2","3","4","NR"), levels = c("0","1","2","3","4","NR")),
        fill = list(n = 0)
      ) |>
      mutate(
        prop = n / sum(n),
        level_chr = as.character(level),
        # üî• COLOR FORZADO POR BARRA (esto garantiza verde/rojo)
        fill_hex = dplyr::case_when(
          level_chr %in% c("3","4") ~ col_autonomia,
          level_chr %in% c("0","1","2") ~ col_apoyo,
          TRUE ~ col_nr
        )
      )

    # Proporciones por categor√≠a institucional
    p_autonomia <- sum(df$prop[df$level_chr %in% c("3","4")])
    p_apoyo     <- sum(df$prop[df$level_chr %in% c("0","1","2")])

    # Desglose por niveles (para predominio interno con cifras)
    p0 <- df$prop[df$level_chr == "0"]
    p1 <- df$prop[df$level_chr == "1"]
    p2 <- df$prop[df$level_chr == "2"]
    p3 <- df$prop[df$level_chr == "3"]
    p4 <- df$prop[df$level_chr == "4"]

    # Predominio interno dentro de autonom√≠a (nivel 3 vs 4)
    w3 <- ifelse(p_autonomia > 0, p3 / p_autonomia, NA_real_)
    w4 <- ifelse(p_autonomia > 0, p4 / p_autonomia, NA_real_)
    aut_dom <- ifelse(
      is.na(w3) | is.na(w4), "sin registro suficiente",
      ifelse(w3 >= w4,
             glue::glue("predomina el nivel 3 (Satisfactorio) con {fmt_pct(w3)} del grupo"),
             glue::glue("predomina el nivel 4 (√ìptimo) con {fmt_pct(w4)} del grupo"))
    )

    # Predominio interno dentro de apoyo (0‚Äì1 vs 2)
    p01 <- p0 + p1
    w01 <- ifelse(p_apoyo > 0, p01 / p_apoyo, NA_real_)
    w2  <- ifelse(p_apoyo > 0, p2  / p_apoyo, NA_real_)
    apo_dom <- ifelse(
      is.na(w01) | is.na(w2), "sin registro suficiente",
      ifelse(w01 >= w2,
             glue::glue("predominan niveles 0‚Äì1 con {fmt_pct(w01)} del grupo"),
             glue::glue("predomina nivel 2 con {fmt_pct(w2)} del grupo"))
    )

    # Texto (cita minimalista) con diferencia + predominio interno con cifras
    dif <- abs(p_autonomia - p_apoyo)
    patron <- dplyr::case_when(
      dif < 0.10 ~ "equilibrio relativo entre ambos grupos",
      dif >= 0.10 & dif < 0.30 ~ "predominio moderado de uno de los grupos",
      dif >= 0.30 ~ "diferencia marcada entre ambos grupos",
      TRUE ~ "diferencias entre ambos grupos"
    )

    texto_analisis <- glue::glue(
      "Los resultados muestran {patron}: **{CAT_AUT}** = {fmt_pct(p_autonomia)} ({aut_dom}) y **{CAT_APO}** = {fmt_pct(p_apoyo)} ({apo_dom})."
    )

    # --- Slide ---
    cat("\n\n---\n\n")
    cat(glue::glue("## {titulo} {{style='font-size: 0.6em; line-height: 1.1;'}}\n\n"))
    cat(":::: {.columns}\n\n")

    # Izquierda: barplot (colores FORZADOS)
    cat("::: {.column width='65%'}\n")

    g <- ggplot(df, aes(x = level, y = prop)) +
      geom_col(aes(fill = fill_hex), width = 0.78) +
      scale_fill_identity() +  # ‚úÖ fuerza el color exacto por barra
      geom_text(
        aes(label = scales::percent(prop, accuracy = 0.1)),
        vjust = -0.55,
        size = 6.0,
        fontface = "bold",
        color = brand_dark
      ) +
      scale_x_discrete(drop = FALSE, labels = nivel_labels) +
      scale_y_continuous(
        labels = NULL,
        limits = c(0, max(df$prop, na.rm = TRUE) * 1.25),
        expand = expansion(mult = c(0, 0.02))
      ) +
      labs(x = NULL, y = NULL) +
      theme(
        panel.grid.major.x = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_text(size = 14, color = brand_text, lineheight = 1.1, margin = margin(t = 10)),
        plot.margin = margin(10, 10, 30, 10)
      )

    print(g)
    cat("\n:::\n")

    # Derecha: indicadores + cita (minimalista)
    cat("::: {.column width='35%'}\n")
    cat("::: {.div style='font-size: 25px; text-align: left; margin-top: 2em;'}\n")

    cat("<div class='analysis-box'>")
    cat("<h4 style='margin-top:0; color:#0a6d7c; border-bottom:1px solid #ccc; font-size:1em;'>Indicadores Clave</h4>")
    cat("<div style='margin-top:14px;'>")
    cat(glue::glue("<div style='font-size:0.95em;'><span style='color:{col_autonomia}; font-weight:800;'>{CAT_AUT}:</span> <strong>{fmt_pct(p_autonomia)}</strong></div>"))
    cat(glue::glue("<div style='font-size:0.95em;'><span style='color:{col_apoyo}; font-weight:800;'>{CAT_APO}:</span> <strong>{fmt_pct(p_apoyo)}</strong></div>"))
    cat("</div>")
    cat("</div>")

    cat("<div style='margin-top: 22px; padding: 15px; background-color: #f0f7f8; border-left: 5px solid #0a6d7c; font-size: 0.85em; line-height: 1.45; color: #2c3e50;'>")
    cat(glue::glue("<em>\"{texto_analisis}\"</em>"))
    cat("</div>")

    cat("<div style='font-size:0.48em; color:#666; line-height:1.25; margin-top:18px;'>")
    cat(glue::glue("<strong>*Lectura institucional:</strong> {CAT_AUT} (niveles 3‚Äì4) y {CAT_APO} (niveles 0‚Äì2)."))
    cat("</div>")

    cat("\n:::\n")  # cierre div
    cat("\n:::\n")  # cierre columna
    cat("::::\n\n")  # cierre columns
  }
}

```


```{r plot_heatmap_III, results='asis', echo=FALSE}
#| fig.width: 15
#| fig.height: 7.5

if (nrow(final_items) > 0) {

  keep_levels <- c("1","2","3","4")

  heat_df <- purrr::map_dfr(seq_len(nrow(final_items)), function(i) {

    col_id <- final_items$col_id[i]
    item   <- stringr::str_wrap(final_items$final_title[i], width = 45)
    x <- dat[[col_id]]

    tibble::tibble(raw = x) %>%
      dplyr::mutate(
        val   = toupper(stringr::str_trim(as.character(raw))),
        num   = suppressWarnings(readr::parse_number(val)),
        level = dplyr::if_else(is.na(num), NA_character_, as.character(num))
      ) %>%
      dplyr::filter(level %in% keep_levels) %>%
      dplyr::count(level, name = "n") %>%
      tidyr::complete(level = keep_levels, fill = list(n = 0)) %>%
      dplyr::mutate(
        prop = if (sum(n) > 0) n / sum(n) else 0,
        item = item
      )
  })

  # orden visual (como tu heatmap)
  heat_df$item <- factor(heat_df$item, levels = rev(unique(heat_df$item)))
  heat_df$level <- factor(heat_df$level, levels = keep_levels)

  # -------------------------------
  # Normalizaci√≥n por columna (nivel):
  # verde m√°ximo = max emp√≠rico dentro de cada columna
  # -------------------------------
  heat_df <- heat_df %>%
    dplyr::group_by(level) %>%
    dplyr::mutate(
      col_max = max(prop, na.rm = TRUE),
      fill_val = dplyr::if_else(col_max > 0, prop / col_max, 0)
    ) %>%
    dplyr::ungroup()

  cat("\n\n---\n\n")
  cat("## Distribuci√≥n de estudiantes por dimension evaluada\n\n")

  nivel_labels_heat <- c(
    "1" = "Insatis.\n(1)",
    "2" = "En desarr.\n(2)",
    "3" = "Satisf.\n(3)",
    "4" = "√ìptimo\n(4)"
  )

  # Paleta institucional (blanco -> verde UAH)
  pal_inst <- c("#ffffff", brand_main)

  g <- ggplot2::ggplot(heat_df, ggplot2::aes(x = level, y = item, fill = fill_val)) +
    ggplot2::geom_tile(color = "white", linewidth = 1.2) +
    ggplot2::scale_fill_gradientn(
      colours = pal_inst,
      limits  = c(0, 1),
      oob     = scales::squish,
      guide   = ggplot2::guide_colorbar(
        ticks = FALSE,
        label = FALSE,
        barheight = grid::unit(6, "cm")
      ),
      name = "Intensidad\n(m√°x. por fila)"
    ) +
    ggplot2::geom_text(
      ggplot2::aes(
        label = scales::percent(prop, accuracy = 1),
        # texto oscuro cuando el fondo es claro
        color = fill_val >= 0.55
      ),
      size = 7,
      fontface = "bold"
    ) +
    ggplot2::scale_color_manual(values = c("TRUE" = "#0b1f1f", "FALSE" = "white"), guide = "none") +
    ggplot2::scale_x_discrete(position = "bottom", labels = nivel_labels_heat) +
    ggplot2::labs(x = NULL, y = NULL) +
    ggplot2::theme_void(base_size = 24) +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(
        size = 18, color = brand_text,
        lineheight = 1.05, margin = ggplot2::margin(t = 15)
      ),
      axis.text.y = ggplot2::element_text(
        size = 18, color = brand_text,
        lineheight = 1.1, hjust = 1, margin = ggplot2::margin(r = 15)
      ),
      legend.position = "right",
      legend.title = ggplot2::element_text(size = 14, face = "bold"),
      legend.key.width = grid::unit(2, "cm"),
      plot.margin = ggplot2::margin(10, 30, 10, 30)
    )

  print(g)
}
```



```{r plot_heatmap_II, results='asis', echo=FALSE}
#| fig.width: 15
#| fig.height: 7.5

if (nrow(final_items) > 0) {

  keep_levels <- c("1","2","3","4")

  heat_df <- purrr::map_dfr(seq_len(nrow(final_items)), function(i) {

    col_id <- final_items$col_id[i]
    item   <- stringr::str_wrap(final_items$final_title[i], width = 45)
    x <- dat[[col_id]]

    tibble::tibble(raw = x) %>%
      dplyr::mutate(
        val   = toupper(stringr::str_trim(as.character(raw))),
        num   = suppressWarnings(readr::parse_number(val)),
        level = dplyr::if_else(is.na(num), NA_character_, as.character(num))
      ) %>%
      dplyr::filter(level %in% keep_levels) %>%
      dplyr::count(level, name = "n") %>%
      tidyr::complete(level = keep_levels, fill = list(n = 0)) %>%
      dplyr::mutate(item = item)
  })

  # 1) Proporci√≥n REAL por columna (cada nivel suma 100% entre √≠tems)
  heat_df <- heat_df %>%
    dplyr::group_by(level) %>%
    dplyr::mutate(
      denom = sum(n),
      denom = ifelse(denom == 0, 1, denom),
      prop  = n / denom
    ) %>%
    dplyr::ungroup() %>%
    dplyr::select(-denom)

  # 2) Escala de color: m√°ximo emp√≠rico POR COLUMNA (m√°x. de prop dentro de cada level)
  heat_df <- heat_df %>%
    dplyr::group_by(level) %>%
    dplyr::mutate(
      max_col  = max(prop, na.rm = TRUE),
      fill_col = ifelse(max_col > 0, prop / max_col, 0)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::select(-max_col)

  heat_df$item <- factor(heat_df$item, levels = rev(unique(heat_df$item)))

  cat("\n\n---\n\n")
  cat("## Distribuci√≥n de estudiantes por nivel de logro\n\n")

  nivel_labels_heat <- c(
    "1" = "Insatis.\n(1)",
    "2" = "En desarr.\n(2)",
    "3" = "Satisf.\n(3)",
    "4" = "√ìptimo\n(4)"
  )

  # ‚úÖ Paleta SOLO del tema: blanco ‚Üí verde institucional
  pal <- c("#ffffff", brand_main)

  g <- ggplot2::ggplot(heat_df, ggplot2::aes(x = level, y = item, fill = fill_col)) +
    ggplot2::geom_tile(color = "white", linewidth = 1.2) +
    scale_fill_gradientn(
  colours = pal,
  limits  = c(0, 1),
  oob     = scales::squish,
  guide   = guide_colorbar(
    ticks = FALSE,
    label = FALSE,
    barheight = unit(6, "cm")
  ),
  name = "Intensidad\n(m√°x. por columna)"
) +
    # ‚úÖ Porcentajes reales en las casillas (prop)
    ggplot2::geom_text(
      ggplot2::aes(
        label = scales::percent(prop, accuracy = 1),
        color = fill_col >= 0.60
      ),
      size = 7,
      fontface = "bold"
    ) +
    ggplot2::scale_color_manual(values = c("TRUE" = "#0b1f1f", "FALSE" = "white"), guide = "none") +
    ggplot2::scale_x_discrete(position = "bottom", labels = nivel_labels_heat) +
    ggplot2::labs(x = NULL, y = NULL) +
    ggplot2::theme_void(base_size = 24) +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(
        size = 18, color = brand_text,
        lineheight = 1.05, margin = ggplot2::margin(t = 15)
      ),
      axis.text.y = ggplot2::element_text(
        size = 18, color = brand_text,
        lineheight = 1.1, hjust = 1, margin = ggplot2::margin(r = 15)
      ),
      legend.position = "right",
      legend.title = ggplot2::element_text(size = 14, face = "bold"),
      legend.key.width = grid::unit(2, "cm"),
      plot.margin = ggplot2::margin(10, 30, 10, 30)
    )

  print(g)
}
```

```{r balance_categorias, results='asis', echo=FALSE}
#| fig.width: 15
#| fig.height: 7.5

if (nrow(final_items) > 0) {

  cat("\n\n---\n\n")
  cat("## Balance por categor√≠as institucionales\n\n")

  # 1) construir data (solo 1‚Äì4)
  balance_df <- purrr::map_dfr(seq_len(nrow(final_items)), function(i) {

    col_id     <- final_items$col_id[i]
    raw_title  <- final_items$final_title[i]
    item_label <- stringr::str_wrap(raw_title, width = 52)

    x <- dat[[col_id]]
    vals_num <- suppressWarnings(readr::parse_number(as.character(x)))
    vals <- vals_num[!is.na(vals_num) & vals_num %in% 1:4]

    if (length(vals) == 0) {
      return(tibble(item = item_label, autonomia = 0, apoyo = 0))
    }

    tibble(v = vals) %>%
      summarise(
        item = item_label,
        autonomia = mean(v %in% 3:4),
        apoyo     = mean(v %in% 1:2)
      )
  }) %>%
    arrange(desc(apoyo)) %>%  # m√°s apoyo arriba
    mutate(item = factor(item, levels = rev(unique(item))))

  plot_df <- balance_df %>%
    tidyr::pivot_longer(
      cols = c(autonomia, apoyo),
      names_to = "categoria",
      values_to = "prop"
    ) %>%
    mutate(
      categoria = dplyr::recode(categoria, autonomia = CAT_AUT, apoyo = CAT_APO),
      categoria = factor(categoria, levels = c(CAT_AUT, CAT_APO)),
      label = ifelse(prop >= 0.08, scales::percent(prop, accuracy = 1), "")
    )

  g <- ggplot(plot_df, aes(x = item, y = prop, fill = categoria)) +
    geom_col(width = 0.70, color = "white", linewidth = 0.6) +
    geom_text(
      aes(label = label),
      position = position_stack(vjust = 0.5),
      color = "white",
      size = 7,              # <- mismo "peso visual" que heatmap
      fontface = "bold"
    ) +
    coord_flip() +
    scale_fill_manual(values = setNames(c(col_apoyo, col_autonomia), c(CAT_APO, CAT_AUT))) +
    scale_y_continuous(limits = c(0, 1), expand = c(0, 0), labels = NULL) +
    labs(x = NULL, y = NULL, fill = NULL) +
    theme_void(base_size = 24) +     # <- mismo base_size que heatmap
    theme(
      axis.text.y = element_text(
        size = 18, color = brand_text,
        lineheight = 1.1, hjust = 1, margin = margin(r = 15)
      ),
      legend.position = "bottom",     # <- igual que heatmap
      legend.title = element_text(size = 14, face = "bold"),
      legend.text  = element_text(size = 14),
      legend.key.width = unit(2, "cm"),
      plot.margin = margin(10, 30, 10, 30)
    )

  print(g)
}
```

```{r resumen_ejecutivo, results='asis', echo=FALSE}
if (exists("final_items") && nrow(final_items) > 0) {

  ranking <- purrr::map_dfr(1:nrow(final_items), function(i) {
    col_id <- final_items$col_id[i]
    titulo <- final_items$final_title[i]
    x <- dat[[col_id]]

    vals_num <- suppressWarnings(readr::parse_number(as.character(x)))
    vals <- vals_num[!is.na(vals_num) & vals_num %in% 0:4]

    if (length(vals) == 0) return(tibble(item = titulo, autonomia = NA_real_))

    p_aut <- mean(vals >= 3)
    tibble(item = titulo, autonomia = p_aut)
  }) %>%
    dplyr::filter(!is.na(autonomia)) %>%
    dplyr::arrange(dplyr::desc(autonomia))

  if (nrow(ranking) == 0) {
    cat("## No hay datos suficientes para el resumen ejecutivo.\n")
  } else {

    top_3 <- head(ranking, 3)
    bottom_3 <- tail(ranking, 3) %>% dplyr::arrange(autonomia)
    promedio_total <- mean(ranking$autonomia, na.rm = TRUE)

    cat("## \n\n")
    cat("### S√≠ntesis de resultados\n\n")
    cat(glue::glue("> Proporci√≥n promedio de **{CAT_AUT}** = **{scales::percent(promedio_total, accuracy=1)}**."))
    cat("\n\n")

    cat(":::: {.columns}\n\n")

    cat('::: {.column width="50%" style="font-size: 28px; text-align: left; margin-top: 2.0em;"}\n\n')
    cat(glue::glue("### Fortalezas (mayor proporci√≥n de {CAT_AUT})\n\n"))
    for (k in 1:nrow(top_3)) {
      cat(glue::glue(
        "* **{stringr::str_trunc(top_3$item[k], 85)}** ‚Äî {scales::percent(top_3$autonomia[k], accuracy=1)}\n"
      ))
    }
    cat("\n:::\n\n")

    cat('::: {.column width="50%" style="font-size: 28px; text-align: left; margin-top: 2.0em;"}\n\n')
    cat(glue::glue("### Prioridades de apoyo (menor proporci√≥n de {CAT_AUT})\n\n"))
    for (k in 1:nrow(bottom_3)) {
      cat(glue::glue(
        "* **{stringr::str_trunc(bottom_3$item[k], 85)}** ‚Äî {scales::percent(bottom_3$autonomia[k], accuracy=1)}\n"
      ))
    }
    cat("\n:::\n\n")

    cat("::::\n\n")

    cat("::: {.div style='font-size: 22px; text-align:left; margin-top: 1.2em; line-height:1.25;'}\n")
    cat("Este s√≠ntesis integra la comparaci√≥n entre ambos grupos y orienta la priorizaci√≥n de apoyos formativos. ")
#    cat("Para cada √≠tem, la composici√≥n interna permite decidir si el foco es **consolidaci√≥n (nivel 2)** o **refuerzo de base (niveles 0‚Äì1)**.\n")
    cat(":::\n")
  }
}
```

```{=html}
<script>
  window.addEventListener("load", (event) => {
    function checkLogo() {
      const isTitleSlide = Reveal.getIndices().h === 0;
      const logo = document.querySelector('.slide-logo');
      if (logo) {
        if (isTitleSlide) {
          logo.style.display = 'none';
          logo.style.visibility = 'hidden';
        } else {
          logo.style.display = 'block';
          logo.style.visibility = 'visible';
        }
      }
    }
    checkLogo();
    Reveal.on('ready', checkLogo);
    Reveal.on('slidechanged', checkLogo);
  });
</script>
```
